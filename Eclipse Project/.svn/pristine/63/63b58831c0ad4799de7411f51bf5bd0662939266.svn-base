/*
 * CSE 593 - Fall 2016 - Applied Project
 * Author  : Lucio Ortiz and Robert Blazewicz
 * Version : DEVSJAVA 3.0
 * Date    : 2016-09-24
 */
package experiment.toolkit;

import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.ParseException;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.lang3.StringUtils;

/**
 * The Class ValueSet.
 */
public class ValueSet {

  /** The consumers. */
  private int consumers;

  /** The experiment. */
  private int experiment;

  /** The version. */
  private char version;

  /** The instance. */
  private int instance;

  /** The counter. */
  private int counter;

  /** The clock. */
  private double clock;

  /** The value map. */
  private Map<String, Value> valueMap = new HashMap<String, Value>();

  /** The Constant defaultFilename. */
  private static final String defaultFilename = "ValueSet.properties";

  /** The pathname. */
  private String pathname;

  /** The filename. */
  private String filename;

  /**
   * Instantiates a new value set.
   *
   * @param experiment the experiment
   * @param version the version
   * @param clock the clock
   */
  public ValueSet(final int experiment, final char version, final double clock) {
    consumers = 2;
    this.experiment = experiment;
    this.version = version;
    instance = 0;
    counter = 0;
    this.clock = clock;

    final Settings settings = SettingsSingleton.getInstance();

    // Resolve path and file name for calibration data file.
    pathname = settings.lookupString("ValueSetPath", settings.getPathname());
    filename = settings.lookupString("ValueSetFile", defaultFilename);
  }

  /**
   * Gets the key.
   *
   * @return the key
   */
  public String getKey() {
    return "VSet:" + experiment + ":" + version + ":" + instance + ":" + counter;
  }

  /**
   * Gets the consumers.
   *
   * @return the consumers
   */
  public int getConsumers() {
    return consumers;
  }

  /**
   * Gets the experiment.
   *
   * @return the experiment
   */
  public int getExperiment() {
    return experiment;
  }

  /**
   * Gets the version.
   *
   * @return the version
   */
  public char getVersion() {
    return version;
  }

  /**
   * Gets the version index.
   *
   * @return the version index
   */
  public int getVersionIndex() {
    return (int)(version - 'A');
  }

  /**
   * Gets the single instance of ValueSet.
   *
   * @return single instance of ValueSet
   */
  public int getInstance() {
    return instance;
  }

  /**
   * Gets the counter.
   *
   * @return the counter
   */
  public int getCounter() {
    return counter;
  }

  /**
   * Gets the clock.
   *
   * @return the clock
   */
  public double getClock() {
    return clock;
  }

  /**
   * Decrement consumers.
   */
  public void decrementConsumers() {
    consumers--;
  }

  /**
   * Increment instance.
   */
  public void incrementInstance() {
    instance++;
  }

  /**
   * Increment counter.
   */
  public void incrementCounter() {
    counter++;
  }

  /**
   * Update clock.
   *
   * @param clock the clock
   */
  public void updateClock(final double clock) {
    if (clock > this.clock)
      this.clock = clock;
    //System.out.println("***** Clock from "+clock+" to "+this.clock);
  }

  /**
   * Debug.
   */
  public void debug() {
    System.out.println(">>> Experiment = "+experiment+
        "\n>>> Version = "+version+
        "\n>>> Instance = "+instance+
        "\n>>> Counter = "+counter+
        "\n>>> clock = "+clock);
    for (Entry<String, Value> entry : valueMap.entrySet()) {
      final Value value = entry.getValue();
      System.out.println(">>> " + entry.getKey() + ": " + value.getValue() +
          " " + value.getUnits() + "\t\t\t\t" + value.getDescription());
    }
  }

  /**
   * Adds the value.
   *
   * @param name the name
   * @param value the value
   * @return the double
   */
  public double addValue(final String name, final double value) {
    valueMap.put(name, new Value(counter, valueMap.size(), name, value));
    return 0;
  }

  /**
   * Adds the value.
   *
   * @param name the name
   * @param value the value
   * @param units the units
   * @return the double
   */
  public double addValue(final String name, final double value, final String units) {
    valueMap.put(name, new Value(counter, valueMap.size(), name, value, units));
    return 0;
  }

  /**
   * Adds the value.
   *
   * @param name the name
   * @param value the value
   * @param units the units
   * @param description the description
   * @return the double
   */
  public double addValue(final String name, final double value, final String units, final String description) {
    valueMap.put(name, new Value(counter, valueMap.size(), name, value, units, description));
    return 0;
  }

  /**
   * Load.
   */
  public void load() {
    loadValueSet();
  }

  /**
   * Load.
   *
   * @param filename the filename
   */
  public void load(final String filename) {
    this.filename = filename;
    loadValueSet();
  }

  /**
   * Load.
   *
   * @param pathname the pathname
   * @param filename the filename
   */
  public void load(final String pathname, final String filename) {
    this.pathname = pathname;
    this.filename = filename;
    loadValueSet();
  }

  /**
   * Load value set.
   */
  private void loadValueSet() {
    final Path filePath = Paths.get(pathname, filename);
    try (FileReader fileReader = new FileReader(filePath.toFile())) {
      try (BufferedReader bufferedReader = new BufferedReader(fileReader)) {
        int lineNumber = 0;
        String line;
        while ((line = bufferedReader.readLine()) != null) {
          lineNumber++;
          if (line.isEmpty() || line.startsWith("#"))
            continue;
          line = StringUtils.strip(line);
          line = line.trim();
          if (line.isEmpty())
            continue;
          final String[] pair = line.split("=");
          if (pair.length == 2) {
            addValue(pair[0].trim(), Double.parseDouble(pair[1].trim()));
          } else
            throw new ParseException("ValueSet file " + filePath + " line " + lineNumber + " has invalid format", 0);
        }
      }
    } catch (Exception e) {
      throw new RuntimeException(e.getMessage());
    }
  }

  /**
   * Value pop.
   *
   * @param someClass the some class
   */
  public void valuePop(Object someClass) {
    final Field[] fields = someClass.getClass().getDeclaredFields();
    for (int i = 0; i < fields.length; i++) {
      final Field field = fields[i];
      final String valueName = field.getName();
      if (valueMap.containsKey(valueName)) {
        final int modifiers = field.getModifiers();
        if (!Modifier.isFinal(modifiers)) {
          final boolean accessible = field.isAccessible();
          if (!accessible)
            field.setAccessible(true);
          final Value value = valueMap.get(valueName);
          try {
            field.set(someClass, value.getValue());
          } catch (IllegalArgumentException|IllegalAccessException e) {
            throw new RuntimeException("ValueSet pop " + valueName + ": " + e.getMessage());
          }
          if (!accessible)
            field.setAccessible(false);
        }
      }
    }
  }

  /**
   * Value push.
   *
   * @param someClass the some class
   */
  public void valuePush(Object someClass) {
    final Field[] fields = someClass.getClass().getDeclaredFields();
    for (int i = 0; i < fields.length; i++) {
      final Field field = fields[i];
      final String valueName = field.getName();
      if (valueMap.containsKey(valueName)) {
        final int modifiers = field.getModifiers();
        if (!Modifier.isFinal(modifiers)) {
          final boolean accessible = field.isAccessible();
          if (!accessible)
            field.setAccessible(true);
          final Value value = valueMap.get(valueName);
          try {
            value.setValue((double) field.get(someClass));
          } catch (IllegalArgumentException|IllegalAccessException e) {
            throw new RuntimeException("ValueSet push " + valueName + ": " + e.getMessage());
          }
          if (!accessible)
            field.setAccessible(false);
        }
      }
    }
  }

  /**
   * Gets the pathname.
   *
   * @return the pathname
   */
  public String getPathname() {
    return pathname;
  }

  /**
   * Gets the filename.
   *
   * @return the filename
   */
  public String getFilename() {
    return filename;
  }
}
