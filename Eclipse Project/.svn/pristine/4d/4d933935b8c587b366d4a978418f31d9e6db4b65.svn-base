/*
 * CSE 593 - Fall 2016 - Applied Project
 * Author  : Lucio Ortiz and Robert Blazewicz
 * Version : DEVSJAVA 3.0
 * Date    : 2016-09-24
 */
package experiment.toolkit;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

/**
 * The Class ValueSet.
 */
public class ValueSet {

  /** The settings. */
  final Settings settings = SettingsSingleton.getInstance();

  /** The consumers. */
  private int consumers;

  /** The experiment. */
  private int experiment;

  /** The version. */
  private char version;

  /** The instance. */
  private int instance;

  /** The mutation. */
  private int mutation;

  /** The value map. */
  private Map<String, Value> valueMap = new HashMap<String, Value>();

  /** The label. */
  private String label;

  /** The debug format. */
  private String debugFormat;

  /**
   * Instantiates a new value set.
   *
   * @param experiment the experiment
   * @param version the version
   * @param clock the clock
   */
  public ValueSet(final int experiment, final char version) {
    consumers = settings.lookupInt("ValueSet_Consumers", "1");
    this.experiment = experiment;
    this.version = version;
    instance = 0;
    mutation = 0;
    label = settings.lookupString("ValueSet_Label", "ValueSet");
    debugFormat = settings.lookupString("ValueSet_DebugFormat", "%-60s ");
  }

  /**
   * Gets the map.
   *
   * @return the map
   */
  public Map<String, Value> getMap() {
    return valueMap;
  }

  /**
   * Gets the key.
   *
   * @return the key
   */
  public String getKey() {
    return label + ":" + experiment + ":" + version + ":" + instance + ":" + mutation;
  }

  /**
   * Gets the consumers.
   *
   * @return the consumers
   */
  public int getConsumers() {
    return consumers;
  }

  /**
   * Gets the experiment.
   *
   * @return the experiment
   */
  public int getExperiment() {
    return experiment;
  }

  /**
   * Gets the version.
   *
   * @return the version
   */
  public char getVersion() {
    return version;
  }

  /**
   * Gets the version index.
   *
   * @return the version index
   */
  public int getVersionIndex() {
    return (int)(version - 'A');
  }

  /**
   * Gets the single instance of ValueSet.
   *
   * @return single instance of ValueSet
   */
  public int getInstance() {
    return instance;
  }

  /**
   * Gets the mutation.
   *
   * @return the mutation
   */
  public int getMutation() {
    return mutation;
  }

  /**
   * Decrement consumers.
   */
  public void decrementConsumers() {
    consumers--;
  }

  /**
   * Increment instance.
   */
  public void incrementInstance() {
    instance++;
  }

  /**
   * Increment mutation.
   */
  public void incrementMutation() {
    mutation++;
  }

  /**
   * Dump.
   */
  public void dump() {
    dump("");
  }

  /**
   * Dump.
   *
   * @param prefix the prefix
   */
  public void dump(final String prefix) {
    System.out.println(prefix + "Experiment = " + experiment +
        "\n" + prefix + "Version = " + version +
        "\n" + prefix + "Instance = " + instance +
        "\n" + prefix + "Mutation = " + mutation);
    for (Entry<String, Value> entry : valueMap.entrySet()) {
      final Value value = entry.getValue();
      final String message = entry.getKey() + ": " + value.getValue() + " " + value.getUnits();
      System.out.println(prefix + String.format(debugFormat, message) + value.getDescription());
    }
  }

  /**
   * Adds the value.
   *
   * @param name the name
   * @param value the value
   * @return the double
   */
  public double addValue(final String name, final double value) {
    valueMap.put(name, new Value(mutation, valueMap.size(), name, value));
    return 0;
  }

  /**
   * Adds the value.
   *
   * @param name the name
   * @param value the value
   * @param units the units
   * @return the double
   */
  public double addValue(final String name, final double value, final String units) {
    valueMap.put(name, new Value(mutation, valueMap.size(), name, value, units));
    return 0;
  }

  /**
   * Adds the value.
   *
   * @param name the name
   * @param value the value
   * @param units the units
   * @param description the description
   * @return the double
   */
  public double addValue(final String name, final double value, final String units, final String description) {
    valueMap.put(name, new Value(mutation, valueMap.size(), name, value, units, description));
    return 0;
  }

  /**
   * Value pop.
   *
   * @param someClass the some class
   */
  public void valuePop(Object someClass) {
    final Field[] fields = someClass.getClass().getDeclaredFields();
    for (int i = 0; i < fields.length; i++) {
      final Field field = fields[i];
      final String valueName = field.getName();
      if (valueMap.containsKey(valueName)) {
        final int modifiers = field.getModifiers();
        if (!Modifier.isFinal(modifiers)) {
          final boolean accessible = field.isAccessible();
          if (!accessible)
            field.setAccessible(true);
          final Value value = valueMap.get(valueName);
          try {
            field.set(someClass, value.getValue());
          } catch (IllegalArgumentException|IllegalAccessException e) {
            throw new RuntimeException("ValueSet pop " + valueName + ": " + e.getMessage());
          }
          if (!accessible)
            field.setAccessible(false);
        }
      }
    }
  }

  /**
   * Value push.
   *
   * @param someClass the some class
   */
  public void valuePush(Object someClass) {
    final Field[] fields = someClass.getClass().getDeclaredFields();
    for (int i = 0; i < fields.length; i++) {
      final Field field = fields[i];
      final String valueName = field.getName();
      if (valueMap.containsKey(valueName)) {
        final int modifiers = field.getModifiers();
        if (!Modifier.isFinal(modifiers)) {
          final boolean accessible = field.isAccessible();
          if (!accessible)
            field.setAccessible(true);
          final Value value = valueMap.get(valueName);
          try {
            value.setValue((double) field.get(someClass));
          } catch (IllegalArgumentException|IllegalAccessException e) {
            throw new RuntimeException("ValueSet push " + valueName + ": " + e.getMessage());
          }
          if (!accessible)
            field.setAccessible(false);
        }
      }
    }
  }
}
